<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TownsOnMap - Server GPX</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
      #map {
        height: 800px;
        width: 100%;
      }
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      #results {
        white-space: pre-wrap;
        margin-top: 20px;
      }
      .custom-div-icon {
        font-weight: bold;
      }
    </style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@raruto/leaflet-elevation@1.0.0/leaflet-elevation.min.css" />
  </head>
  <body>
<!--    <h1>Towns On Map (Load GPX from Server)</h1>
    <p>
      Pass the GPX file URL as a query parameter <code>gpxFile</code> in the URL.<br />
      Example: <code>?gpxFile=path/to/your/file.gpx</code>
    </p> -->

    <div id="map"></div>
<!--    <div id="results"></div> -->

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/2.2.0/gpx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.min.js"></script>
    <script src="https://unpkg.com/@raruto/leaflet-elevation/dist/leaflet-elevation.js"></script>

    <script>
      // Global towns data placeholder
      let towns = [];

      // Utility: Get URL query parameter by name
      function getQueryParam(name) {
        const params = new URLSearchParams(window.location.search);
        return params.get(name);
      }

function parseGPX(gpxText) {
  const parser = new DOMParser();
  const xml = parser.parseFromString(gpxText, 'application/xml');

  // Use getElementsByTagName to avoid namespace issues
  const trkpts = Array.from(xml.getElementsByTagName('trkpt'));

  // Map and parse lat/lon with fallback parseFloat (+ to convert string)
  return trkpts.map(pt => {
    const latStr = pt.getAttribute('lat');
    const lonStr = pt.getAttribute('lon');
    const lat = latStr ? parseFloat(latStr) : NaN;
    const lon = lonStr ? parseFloat(lonStr) : NaN;
    const eleEl = pt.querySelector('ele');
    const ele = eleEl ? parseFloat(eleEl.textContent) : 0;
   return { lat, lon, ele };
  }).filter(point => !isNaN(point.lat) && !isNaN(point.lon)); // Filter out any invalid points
}

      // Haversine distance in kilometers
      function distance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLon = ((lon2 - lon1) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLon / 2) ** 2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }

      // Find polylines inside a GPX layer (for arrow decoration)
      function findPolylinesInGPXLayer(gpxLayer) {
        let polylines = [];
        Object.values(gpxLayer._layers).forEach((firstLevelLayer) => {
          if (firstLevelLayer._layers) {
            Object.values(firstLevelLayer._layers).forEach((secondLevelLayer) => {
              if (
                Array.isArray(secondLevelLayer._latlngs) &&
                secondLevelLayer._latlngs.length > 1
              ) {
                polylines.push(secondLevelLayer);
              }
            });
          } else {
            if (
              Array.isArray(firstLevelLayer._latlngs) &&
              firstLevelLayer._latlngs.length > 1
            ) {
              polylines.push(firstLevelLayer);
            }
          }
        });
        return polylines;
      }

  function interpolatePointOnLine(latlngs, ratio, map) {
  let totalDistance = 0;
  const distances = [];

  // Calculate distances between consecutive points
  for (let i = 0; i < latlngs.length - 1; i++) {
    const dist = map.distance(latlngs[i], latlngs[i + 1]);
    distances.push(dist);
    totalDistance += dist;
  }

  const targetDistance = totalDistance * ratio; // e.g. 0.25 for 25%
  let accumulated = 0;

  // Find segment containing target distance
  for (let i = 0; i < distances.length; i++) {
    if (accumulated + distances[i] >= targetDistance) {
      const segmentRatio = (targetDistance - accumulated) / distances[i];

      const lat = latlngs[i].lat + segmentRatio * (latlngs[i + 1].lat - latlngs[i].lat);
      const lng = latlngs[i].lng + segmentRatio * (latlngs[i + 1].lng - latlngs[i].lng);

      return L.latLng(lat, lng);
    }
    accumulated += distances[i];
  }

  // If ratio is 1 or very close, return last point
  return latlngs[latlngs.length - 1];
} //function interpolatePointOnLine

      
function distanceToNearestVertex(latlngs, target, tolerance, map) {
  let totalDistance = 0;
  let minDistance = Infinity;
  let distanceAlong = null;

  for (let i = 0; i < latlngs.length; i++) {
    const dist = map.distance(latlngs[i], target);
    if (dist < minDistance && dist <= tolerance) {
      minDistance = dist;
      distanceAlong = totalDistance;
    }
    if (i < latlngs.length - 1) {
      totalDistance += map.distance(latlngs[i], latlngs[i + 1]);
    }
  }

  return distanceAlong; // returns null if none within tolerance
}

      // Fetch towns data from your Google Apps Script endpoint
      async function getTowns() {
        const response = await fetch(
          'https://script.google.com/macros/s/AKfycbxPapZqH6M-bVeiFCtXjYzlMTPlR_86k5X_XCGrB34hES_p7y9GIpSmavdzqb-xFrrohQ/exec?sheet=Villages'
        );
        return await response.json();
      }

   let distAlong;
  let targetPoint;
      
  async function loadGPXFromServer() {

  const waterIcon = new L.Icon({
  iconUrl: 'water.png',
//  shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
  iconSize: [30, 30],
  iconAnchor: [15, 15],
  popupAnchor: [1, -30],
//  shadowSize: [41, 41]
});

const tapIcon = new L.Icon({
  iconUrl: 'tap.png',
//  shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
  iconSize: [30, 30],
  iconAnchor: [15, 15],
  popupAnchor: [1, -30],
//  shadowSize: [41, 41]
});

const fountainIcon = new L.Icon({
  iconUrl: 'fountain.png',
//  shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
  iconSize: [30, 30],
  iconAnchor: [15, 15],
  popupAnchor: [1, -30],
//  shadowSize: [41, 41]
});

const toiletsIcon = new L.Icon({
  iconUrl: 'toilets.png',
//  shadowUrl: 'https://unpkg.com/leaflet@1.9.4/dist/images/marker-shadow.png',
  iconSize: [30, 30],
  iconAnchor: [15, 15],
  popupAnchor: [1, -30],
//  shadowSize: [41, 41]
});

  const coffeeIcon = new L.Icon({
  iconUrl: 'coffee.png',
  iconSize: [30, 30],
  iconAnchor: [15, 15],
}); //const coffeeIcon

        const coffeeLat = getQueryParam('clat');
       const coffeeLon = getQueryParam('clon');
       const dist = getQueryParam('dist');
       const deniv = getQueryParam('deniv');
        
      const filename = getQueryParam('gpxFile');
        if (!filename) {
          alert('No GPX filename specified in URL query parameter "gpxFile".');
          return;
        } //if (!filename)
        try {
          const response = await fetch("gpx/"+filename);
          if (!response.ok) {
            alert('Failed to load GPX file from server: ' + filename);
            return;
          } //if (!response.ok)
          
          const gpxText = await response.text();
          const mypoints = parseGPX(gpxText);
          
          const pdeproximityKm = 0.1;
           let pdeEncountered = [];

  await fetch('eau.json')
  .then(response => response.json())
  .then(locations => {
    locations.forEach(loc => {

 if (loc.Display == 'Y') {

            for (const pt of mypoints) {
              if (
                distance(pt.lat, pt.lon, loc.Lat, loc.Lon) <= pdeproximityKm
              ) {
                pdeEncountered.push(loc);
                break;
              } //if
            } //for (const pt of mypoints)
 } //if (loc.Display == 'Y')
  }); //locations.forEach
  }); //locations
                    const townproximityKm = 0.25;

         let townsEncountered = [];

          towns.forEach((town) => {
            for (const pt of mypoints) {
              if (
                distance(pt.lat, pt.lon, town.Lat, town.Lon) <= townproximityKm
              ) {
                townsEncountered.push(town);
                break;
              } //if
            } //for (const pt of mypoints)
          }); //towns.forEach

          // Sort and deduplicate towns by Place name (and coordinates for safety)
          townsEncountered.sort((a, b) => a.Place.localeCompare(b.Place));
          const filteredTowns = townsEncountered.filter(
            (t, i, arr) =>
              i === 0 ||
              !(
                t.Place === arr[i - 1].Place //&&
              //  t.Lat === arr[i - 1].Lat &&
            //    t.Lon === arr[i - 1].Lon
              )
          ); //const filteredTowns

          // Initialize or clear map layers and markers
          if (!window.map || !(window.map instanceof L.Map)) {
            window.map = L.map('map').setView([43.6, 2], 10);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              attribution: '© OpenStreetMap contributors',
            }).addTo(window.map);
          } else {
            window.map.eachLayer((layer) => {
              if (!(layer instanceof L.TileLayer)) {
                window.map.removeLayer(layer);
              }
            });
          } //if (!window.map || !(window.map instanceof L.Map))

          // Add GPX layer with arrow decorations
          new L.GPX(gpxText, { async: true,
                  markers: {
                    startIcon: 'start.ico',
                    endIcon: 'finish.ico'
                  }, //markers
                  marker_options: {
                    iconSize: [12, 12],
                    iconAnchor: [6, 6],
                  } //marker_options
                })
            .on('loaded', function (e) {
              const gpxLayer = e.target;
              window.map.fitBounds(gpxLayer.getBounds());

 
              const polylines = findPolylinesInGPXLayer(gpxLayer);
              
              polylines.forEach((polyline) => {
                L.polylineDecorator(polyline, {
                  patterns: [
                    {
                      offset: '3%',
                      repeat: '5%',
                      symbol: L.Symbol.arrowHead({
                        pixelSize: 12,
                        polygon: true,
                        pathOptions: {
                          color: 'blue',
                          weight: 2,
                          opacity: 1,
                          fill: true,
                          fillColor: 'blue',
                          fillOpacity: 1,
                        }, //pathOptions
                      }), //L.Symbol.arrowHead
                    },
                  ], //patterns
                }).addTo(window.map); //L.polylineDecorator(polyline
   //             polyline.bindTooltip('This is my path');
 const poplatlngs = polyline.getLatLngs();
const popupPoint = interpolatePointOnLine(poplatlngs, 0.25, window.map);

//polyline.bindPopup("Parcours : "+dist+"km, "+deniv+"m").openPopup(popupPoint);
let popup1 = L.popup()
  .setLatLng(popupPoint)
  .setContent("<span style='font-size: 10px'>Parcours : "+dist+"km, "+deniv+"m</span>")
  .addTo(window.map);


                targetPoint = L.latLng(coffeeLat, coffeeLon); // example coordinate
const toleranceMeters = 50;

distAlong = distanceToNearestVertex(poplatlngs, targetPoint, toleranceMeters, window.map);
if (distAlong !== null) {
  console.log(`Nearest vertex is approximately ${distAlong.toFixed(1)} meters along the polyline.`);
} else {
  console.log('No vertex found within 50m of the target point.');
}
//               polyline.bindPopup('My path popup').openPopup();
         const cMarker = L.marker([coffeeLat, coffeeLon], { icon: coffeeIcon, zIndexOffset: 1000 }).addTo(window.map);
          const kms = Math.round(distAlong / 1000);
                
          let popup2 = L.popup()
          .setLatLng([coffeeLat, coffeeLon])
          .setContent("<span style='font-size: 10px'>Pause Café à "+kms+"km</span>")
          .addTo(window.map);

//          cMarker.bindPopup("À "+kms+"km").openPopup();
               }); //polylines.forEach
            }) //.on('loaded'
            .addTo(window.map);

          // Add town markers
          filteredTowns.forEach((ft) => {
            const myIcon = L.divIcon({
              className: 'custom-div-icon',
              html: `<span style="color:red; background-color: yellow; white-space: nowrap; opacity: 0.8;"><strong>${ft.Place}</strong></span>`,
              iconSize: [ft.Place.length * 10, 20],
              iconAnchor: [ft.Place.length * 5, 10],
            }); //const myIcon
            L.marker([ft.Lat, ft.Lon], { icon: myIcon }).addTo(window.map);
          }); //filteredTowns.forEach

          pdeEncountered.forEach((pe) => {
    let iconToUse;
    if (pe.Type === 'Fontaine') {
      iconToUse = fountainIcon;
    } else if (pe.Type === 'Robinet') {
      iconToUse = tapIcon;
    } else if (pe.Type === 'Toilettes') {
      iconToUse = toiletsIcon;
//    } else if (loc.Genre === 'SOURCE') {
//      iconToUse = blueIcon;
    } else if (pe.Type === 'Point d\'Eau') {
      iconToUse = waterIcon;
    }

            L.marker([pe.Lat, pe.Lon], { icon: iconToUse }).addTo(window.map);
          }); //pdeEncountered.forEach

 var controlElevation = L.control.elevation({
    position: "topright",
    theme: "steelblue-theme",
    width: 600,
    height: 125,
    autopan: true,
    followMarker: true,
    distanceUnit: "km",
    elevationUnit: "m"
}).addTo(window.map);

console.log(Array.isArray(mypoints)); // should be true
console.log(Object.prototype.toString.call(mypoints)); // should print [object 
          const geojson = {
  type: 'FeatureCollection',
  features: [{
    type: 'Feature',
    geometry: {
      type: 'LineString',
      coordinates: mypoints.map(p => [p[2], p[1], p[0]]) // [lon, lat, ele]
    },
    properties: {}
  }]
};

          console.log(geojson);

// Load the GeoJSON into the elevation control
///controlElevation.load(geojson);


          // Show visited towns in results div
//          const resultsDiv = document.getElementById('results');
  //        resultsDiv.textContent = 'Towns visited:\n' + filteredTowns.map(t => t.Place).join('\n');
        } catch (error) {
          alert('Error loading or processing GPX file.');
          console.error(error);
        } //try
      } //async function loadGPXFromServer

      // Main function to start everything
      async function main() {
        towns = await getTowns();
        await loadGPXFromServer();
      }

      main();
    </script>
  </body>
</html>
