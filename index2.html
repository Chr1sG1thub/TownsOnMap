<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TownsOnMap - Server GPX</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
      #map {
        height: 800px;
        width: 100%;
      }
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      #results {
        white-space: pre-wrap;
        margin-top: 20px;
      }
      .custom-div-icon {
        font-weight: bold;
      }
    </style>
  </head>
  <body>
<!--    <h1>Towns On Map (Load GPX from Server)</h1>
    <p>
      Pass the GPX file URL as a query parameter <code>gpxFile</code> in the URL.<br />
      Example: <code>?gpxFile=path/to/your/file.gpx</code>
    </p> -->

    <div id="map"></div>
<!--    <div id="results"></div> -->

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/2.2.0/gpx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.min.js"></script>

    <script>
      // Global towns data placeholder
      let towns = [];

      // Utility: Get URL query parameter by name
      function getQueryParam(name) {
        const params = new URLSearchParams(window.location.search);
        return params.get(name);
      }

function parseGPX(gpxText) {
  const parser = new DOMParser();
  const xml = parser.parseFromString(gpxText, 'application/xml');

  // Use getElementsByTagName to avoid namespace issues
  const trkpts = Array.from(xml.getElementsByTagName('trkpt'));

  // Map and parse lat/lon with fallback parseFloat (+ to convert string)
  return trkpts.map(pt => {
    const latStr = pt.getAttribute('lat');
    const lonStr = pt.getAttribute('lon');
    const lat = latStr ? parseFloat(latStr) : NaN;
    const lon = lonStr ? parseFloat(lonStr) : NaN;
    return { lat, lon };
  }).filter(point => !isNaN(point.lat) && !isNaN(point.lon)); // Filter out any invalid points
}

      // Haversine distance in kilometers
      function distance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLon = ((lon2 - lon1) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLon / 2) ** 2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }

      // Find polylines inside a GPX layer (for arrow decoration)
      function findPolylinesInGPXLayer(gpxLayer) {
        let polylines = [];
        Object.values(gpxLayer._layers).forEach((firstLevelLayer) => {
          if (firstLevelLayer._layers) {
            Object.values(firstLevelLayer._layers).forEach((secondLevelLayer) => {
              if (
                Array.isArray(secondLevelLayer._latlngs) &&
                secondLevelLayer._latlngs.length > 1
              ) {
                polylines.push(secondLevelLayer);
              }
            });
          } else {
            if (
              Array.isArray(firstLevelLayer._latlngs) &&
              firstLevelLayer._latlngs.length > 1
            ) {
              polylines.push(firstLevelLayer);
            }
          }
        });
        return polylines;
      }

  function interpolatePointOnLine(latlngs, ratio, map) {
  let totalDistance = 0;
  const distances = [];

  // Calculate distances between consecutive points
  for (let i = 0; i < latlngs.length - 1; i++) {
    const dist = map.distance(latlngs[i], latlngs[i + 1]);
    distances.push(dist);
    totalDistance += dist;
  }

  const targetDistance = totalDistance * ratio; // e.g. 0.25 for 25%
  let accumulated = 0;

  // Find segment containing target distance
  for (let i = 0; i < distances.length; i++) {
    if (accumulated + distances[i] >= targetDistance) {
      const segmentRatio = (targetDistance - accumulated) / distances[i];

      const lat = latlngs[i].lat + segmentRatio * (latlngs[i + 1].lat - latlngs[i].lat);
      const lng = latlngs[i].lng + segmentRatio * (latlngs[i + 1].lng - latlngs[i].lng);

      return L.latLng(lat, lng);
    }
    accumulated += distances[i];
  }

  // If ratio is 1 or very close, return last point
  return latlngs[latlngs.length - 1];
} //function interpolatePointOnLine

      
function pointToSegmentDistance(p, p1, p2, map) {
  // Project point p onto segment p1-p2 and return closest point and distance in meters
  const toLatLng = (pt) => L.latLng(pt.lat, pt.lng);

  const A = map.latLngToLayerPoint(toLatLng(p));
  const B = map.latLngToLayerPoint(toLatLng(p1));
  const C = map.latLngToLayerPoint(toLatLng(p2));

  const AB = C.subtract(B);
  const AP = A.subtract(B);
  const ab2 = AB.x * AB.x + AB.y * AB.y;
  const ap_ab = AP.x * AB.x + AP.y * AB.y;
  let t = ap_ab / ab2;

  t = Math.max(0, Math.min(1, t));

  const closest = L.point(B.x + AB.x * t, B.y + AB.y * t);
  const closestLatLng = map.layerPointToLatLng(closest);
  const distance = map.distance(p, closestLatLng);

  return { closestLatLng, distance, t };
} //function pointToSegmentDistance

function distanceAlongPolylineAtPoint(latlngs, target, tolerance, map) {
  let totalDistance = 0;

  for (let i = 0; i < latlngs.length - 1; i++) {
    const segmentStart = latlngs[i];
    const segmentEnd = latlngs[i + 1];

    const { closestLatLng, distance, t } = pointToSegmentDistance(target, segmentStart, segmentEnd, map);

    if (distance <= tolerance) {
      // Calculate distance up to closest point on segment
      const segmentDistance = map.distance(segmentStart, segmentEnd);
      return totalDistance + segmentDistance * t;
    }

    totalDistance += map.distance(segmentStart, segmentEnd);
  }

  // If target is not within tolerance on any segment, return null
  return null;
} //function distanceAlongPolylineAtPoint

      // Fetch towns data from your Google Apps Script endpoint
      async function getTowns() {
        const response = await fetch(
          'https://script.google.com/macros/s/AKfycbxPapZqH6M-bVeiFCtXjYzlMTPlR_86k5X_XCGrB34hES_p7y9GIpSmavdzqb-xFrrohQ/exec?sheet=Villages'
        );
        return await response.json();
      }

      async function loadGPXFromServer() {

  const coffeeIcon = new L.Icon({
  iconUrl: 'coffee.png',
  iconSize: [30, 30],
  iconAnchor: [15, 15],
}); //const coffeeIcon

        const coffeeLat = getQueryParam('clat');
       const coffeeLon = getQueryParam('clon');
       const dist = getQueryParam('dist');
       const deniv = getQueryParam('deniv');
        
      const filename = getQueryParam('gpxFile');
        if (!filename) {
          alert('No GPX filename specified in URL query parameter "gpxFile".');
          return;
        } //if (!filename)
        try {
          const response = await fetch("gpx/"+filename);
          if (!response.ok) {
            alert('Failed to load GPX file from server: ' + filename);
            return;
          } //if (!response.ok)
          const gpxText = await response.text();
          const points = parseGPX(gpxText);
          const proximityKm = 0.1;
          let townsEncountered = [];

          towns.forEach((town) => {
            points.forEach((pt) => {
              if (
                distance(pt.lat, pt.lon, town.Lat, town.Lon) <= proximityKm
              ) {
                townsEncountered.push(town);
              } //if
            }); //points.forEach
          }); //towns.forEach

          // Sort and deduplicate towns by Place name (and coordinates for safety)
          townsEncountered.sort((a, b) => a.Place.localeCompare(b.Place));
          const filteredTowns = townsEncountered.filter(
            (t, i, arr) =>
              i === 0 ||
              !(
                t.Place === arr[i - 1].Place //&&
              //  t.Lat === arr[i - 1].Lat &&
            //    t.Lon === arr[i - 1].Lon
              )
          ); //const filteredTowns

          // Initialize or clear map layers and markers
          if (!window.map || !(window.map instanceof L.Map)) {
            window.map = L.map('map').setView([43.6, 2], 10);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              attribution: 'Â© OpenStreetMap contributors',
            }).addTo(window.map);
          } else {
            window.map.eachLayer((layer) => {
              if (!(layer instanceof L.TileLayer)) {
                window.map.removeLayer(layer);
              }
            });
          } //if (!window.map || !(window.map instanceof L.Map))

          // Add GPX layer with arrow decorations
          new L.GPX(gpxText, { async: true,
                  markers: {
                    startIcon: 'start.ico',
                    endIcon: 'finish.ico'
                  }, //markers
                  marker_options: {
                    iconSize: [12, 12],
                    iconAnchor: [6, 6],
                  } //marker_options
                })
            .on('loaded', function (e) {
              const gpxLayer = e.target;
              window.map.fitBounds(gpxLayer.getBounds());

 
              const polylines = findPolylinesInGPXLayer(gpxLayer);
              
              polylines.forEach((polyline) => {
                L.polylineDecorator(polyline, {
                  patterns: [
                    {
                      offset: '3%',
                      repeat: '5%',
                      symbol: L.Symbol.arrowHead({
                        pixelSize: 12,
                        polygon: true,
                        pathOptions: {
                          color: 'blue',
                          weight: 2,
                          opacity: 1,
                          fill: true,
                          fillColor: 'blue',
                          fillOpacity: 1,
                        }, //pathOptions
                      }), //L.Symbol.arrowHead
                    },
                  ], //patterns
                }).addTo(window.map); //L.polylineDecorator(polyline
   //             polyline.bindTooltip('This is my path');
 const poplatlngs = polyline.getLatLngs();
const popupPoint = interpolatePointOnLine(poplatlngs, 0.25, window.map);

polyline.bindPopup("Parcours : "+dist+"km, "+deniv+"m").openPopup(popupPoint);

                const targetPoint = L.latLng(coffeeLat, coffeeLon); // example coordinate
const toleranceMeters = 50;

const distanceAlong = distanceAlongPolylineAtPoint(poplatlngs, targetPoint, toleranceMeters, window.map);
                console.log(distanceAlong);

//               polyline.bindPopup('My path popup').openPopup();
              }); //polylines.forEach
            }) //.on('loaded'
            .addTo(window.map);

          // Add town markers
          filteredTowns.forEach((ft) => {
            const myIcon = L.divIcon({
              className: 'custom-div-icon',
              html: `<span style="color:red; background-color: yellow; white-space: nowrap; opacity: 0.8;"><strong>${ft.Place}</strong></span>`,
              iconSize: [ft.Place.length * 10, 20],
              iconAnchor: [ft.Place.length * 5, 10],
            }); //const myIcon
            L.marker([ft.Lat, ft.Lon], { icon: myIcon }).addTo(window.map);
          }); //filteredTowns.forEach

          const marker = L.marker([coffeeLat, coffeeLon], { icon: coffeeIcon, zIndexOffset: 1000 }).addTo(window.map);


          // Show visited towns in results div
//          const resultsDiv = document.getElementById('results');
  //        resultsDiv.textContent = 'Towns visited:\n' + filteredTowns.map(t => t.Place).join('\n');
        } catch (error) {
          alert('Error loading or processing GPX file.');
          console.error(error);
        } //try
      } //async function loadGPXFromServer

      // Main function to start everything
      async function main() {
        towns = await getTowns();
        await loadGPXFromServer();
      }

      main();
    </script>
  </body>
</html>
