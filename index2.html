<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>TownsOnMap - Server GPX</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
    <style>
      #map {
        height: 800px;
        width: 100%;
      }
      body {
        font-family: Arial, sans-serif;
        margin: 20px;
      }
      #results {
        white-space: pre-wrap;
        margin-top: 20px;
      }
      .custom-div-icon {
        font-weight: bold;
      }
    </style>
  </head>
  <body>
<!--    <h1>Towns On Map (Load GPX from Server)</h1>
    <p>
      Pass the GPX file URL as a query parameter <code>gpxFile</code> in the URL.<br />
      Example: <code>?gpxFile=path/to/your/file.gpx</code>
    </p> -->

    <div id="map"></div>
<!--    <div id="results"></div> -->

    <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/2.2.0/gpx.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.min.js"></script>

    <script>
      // Global towns data placeholder
      let towns = [];

      // Utility: Get URL query parameter by name
      function getQueryParam(name) {
        const params = new URLSearchParams(window.location.search);
        return params.get(name);
      }

function parseGPX(gpxText) {
  const parser = new DOMParser();
  const xml = parser.parseFromString(gpxText, 'application/xml');

  // Use getElementsByTagName to avoid namespace issues
  const trkpts = Array.from(xml.getElementsByTagName('trkpt'));

  // Map and parse lat/lon with fallback parseFloat (+ to convert string)
  return trkpts.map(pt => {
    const latStr = pt.getAttribute('lat');
    const lonStr = pt.getAttribute('lon');
    const lat = latStr ? parseFloat(latStr) : NaN;
    const lon = lonStr ? parseFloat(lonStr) : NaN;
    return { lat, lon };
  }).filter(point => !isNaN(point.lat) && !isNaN(point.lon)); // Filter out any invalid points
}

      // Haversine distance in kilometers
      function distance(lat1, lon1, lat2, lon2) {
        const R = 6371;
        const dLat = ((lat2 - lat1) * Math.PI) / 180;
        const dLon = ((lon2 - lon1) * Math.PI) / 180;
        const a =
          Math.sin(dLat / 2) ** 2 +
          Math.cos((lat1 * Math.PI) / 180) *
            Math.cos((lat2 * Math.PI) / 180) *
            Math.sin(dLon / 2) ** 2;
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      }

      // Find polylines inside a GPX layer (for arrow decoration)
      function findPolylinesInGPXLayer(gpxLayer) {
        let polylines = [];
        Object.values(gpxLayer._layers).forEach((firstLevelLayer) => {
          if (firstLevelLayer._layers) {
            Object.values(firstLevelLayer._layers).forEach((secondLevelLayer) => {
              if (
                Array.isArray(secondLevelLayer._latlngs) &&
                secondLevelLayer._latlngs.length > 1
              ) {
                polylines.push(secondLevelLayer);
              }
            });
          } else {
            if (
              Array.isArray(firstLevelLayer._latlngs) &&
              firstLevelLayer._latlngs.length > 1
            ) {
              polylines.push(firstLevelLayer);
            }
          }
        });
        return polylines;
      }

      // Fetch towns data from your Google Apps Script endpoint
      async function getTowns() {
        const response = await fetch(
          'https://script.google.com/macros/s/AKfycbxPapZqH6M-bVeiFCtXjYzlMTPlR_86k5X_XCGrB34hES_p7y9GIpSmavdzqb-xFrrohQ/exec?sheet=Villages'
        );
        return await response.json();
      }

      async function loadGPXFromServer() {

  const coffeeIcon = new L.Icon({
  iconUrl: 'coffee.png',
  iconSize: [30, 30],
  iconAnchor: [15, 15],
});

        const coffeeLat = getQueryParam('lat');
       const coffeeLon = getQueryParam('lon');
      const filename = getQueryParam('gpxFile');
        if (!filename) {
          alert('No GPX filename specified in URL query parameter "gpxFile".');
          return;
        }
        try {
          const response = await fetch(filename);
          if (!response.ok) {
            alert('Failed to load GPX file from server: ' + filename);
            return;
          }
          const gpxText = await response.text();
          const points = parseGPX(gpxText);
          const proximityKm = 0.1;
          let townsEncountered = [];

          towns.forEach((town) => {
            points.forEach((pt) => {
              if (
                distance(pt.lat, pt.lon, town.Lat, town.Lon) <= proximityKm
              ) {
                townsEncountered.push(town);
              }
            });
          });

          // Sort and deduplicate towns by Place name (and coordinates for safety)
          townsEncountered.sort((a, b) => a.Place.localeCompare(b.Place));
          const filteredTowns = townsEncountered.filter(
            (t, i, arr) =>
              i === 0 ||
              !(
                t.Place === arr[i - 1].Place //&&
              //  t.Lat === arr[i - 1].Lat &&
            //    t.Lon === arr[i - 1].Lon
              )
          );

          // Initialize or clear map layers and markers
          if (!window.map || !(window.map instanceof L.Map)) {
            window.map = L.map('map').setView([43.6, 2], 10);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
              attribution: 'Â© OpenStreetMap contributors',
            }).addTo(window.map);
          } else {
            window.map.eachLayer((layer) => {
              if (!(layer instanceof L.TileLayer)) {
                window.map.removeLayer(layer);
              }
            });
          }

          // Add GPX layer with arrow decorations
          new L.GPX(gpxText, { async: true,
                  markers: {
                    startIcon: 'start.ico',
                    endIcon: 'finish.ico'
                  }, //markers
                  marker_options: {
                    iconSize: [12, 12],
                    iconAnchor: [6, 6],
                  } //marker_options
                })
            .on('loaded', function (e) {
              const gpxLayer = e.target;
              window.map.fitBounds(gpxLayer.getBounds());

                const marker = L.marker([coffeeLat, coffeeLon], { icon: coffeeIcon }).addTo(window.map);

              const polylines = findPolylinesInGPXLayer(gpxLayer);
              polylines.forEach((polyline) => {
                L.polylineDecorator(polyline, {
                  patterns: [
                    {
                      offset: '3%',
                      repeat: '5%',
                      symbol: L.Symbol.arrowHead({
                        pixelSize: 12,
                        polygon: true,
                        pathOptions: {
                          color: 'blue',
                          weight: 2,
                          opacity: 1,
                          fill: true,
                          fillColor: 'blue',
                          fillOpacity: 1,
                        },
                      }),
                    },
                  ],
                }).addTo(window.map);
              });
            })
            .addTo(window.map);

          // Add town markers
          filteredTowns.forEach((ft) => {
            const myIcon = L.divIcon({
              className: 'custom-div-icon',
              html: `<span style="color:red; background-color: yellow; white-space: nowrap; opacity: 0.8;"><strong>${ft.Place}</strong></span>`,
              iconSize: [ft.Place.length * 10, 20],
              iconAnchor: [ft.Place.length * 5, 10],
            });
            L.marker([ft.Lat, ft.Lon], { icon: myIcon }).addTo(window.map);
          });

          // Show visited towns in results div
//          const resultsDiv = document.getElementById('results');
  //        resultsDiv.textContent = 'Towns visited:\n' + filteredTowns.map(t => t.Place).join('\n');
        } catch (error) {
          alert('Error loading or processing GPX file.');
          console.error(error);
        }
      }

      // Main function to start everything
      async function main() {
        towns = await getTowns();
        await loadGPXFromServer();
      }

      main();
    </script>
  </body>
</html>
