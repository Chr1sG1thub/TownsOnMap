<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Carte</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/2.2.0/gpx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.min.js"></script>
  <script src="https://unpkg.com/@mapbox/togeojson@0.16.2/togeojson.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@turf/turf@7/turf.min.js"></script>
 

  <style>
    #map { height: 800px; width: 100%; }
    body { font-family: Arial, sans-serif; margin: 20px; }
    #results { white-space: pre-wrap; margin-top: 20px; }
    .custom-div-icon { font-weight: bold; }
    .controls { margin-bottom: 20px; padding: 10px; background: #f0f0f0; border-radius: 5px; display: none;}
    .status { margin: 10px 0; padding: 10px; background: #e0f7fa; border-radius: 5px; font-size: 14px; }
    
.elevationpop .leaflet-popup-content-wrapper {background-color: palegreen; padding: 4px;}
    
.elevationpop .leaflet-popup-tip {
   background-color: palegreen; width: 10px;  margin-top: -10px; margin-right: 16px; margin-bottom: 0px; margin-left: 16px;
}

.elevationpop .leaflet-popup-content {
  margin-top: 3px;
  margin-left: 0px;
  margin-bottom: 0px;
  margin-right: 20px;
  font-size: 10px;
}

.cafepop .leaflet-popup-content-wrapper {background-color: wheat; padding: 4px;}
    
.cafepop .leaflet-popup-tip {
   background-color: wheat; width: 10px;  margin-top: -10px; margin-right: 16px; margin-bottom: 0px; margin-left: 16px;
}

.cafepop .leaflet-popup-content {
  margin-top: 3px;
  margin-left: 0px;
  margin-bottom: 0px;
  margin-right: 20px;
  font-size: 10px;
}

.parcourspop .leaflet-popup-content-wrapper {background-color: powderblue; padding: 4px;}
    
.parcourspop .leaflet-popup-tip {
   <!--background-color: powderblue; width: 10px;  margin-top: -10px; margin-right: 16px; margin-bottom: 0px; margin-left: 16px;-->
     display: none;
}
.parcourspop .leaflet-popup-tip-container {
   <!--background-color: powderblue; width: 10px;  margin-top: -10px; margin-right: 16px; margin-bottom: 0px; margin-left: 16px;-->
     display: none;
}
.parcourspop .leaflet-popup-content {
  margin-top: 3px;
  margin-left: 0px;
  margin-bottom: 0px;
  margin-right: 20px;
  font-size: 10px;
}

  </style>
</head>

<body>
  <div id="controls" class="controls">
    <input type="file" id="gpxFile" accept=".gpx" style="margin-right: 10px;">
    <!-- <span id="urlStatus">Checking URL parameters...</span> -->
  </div>
  
  <div id="map"></div>

  <script>
    let map;
    let towns = [];

    function getQueryParam(name) {
      const value = new URLSearchParams(window.location.search).get(name);
//      console.log(`Query param "${name}":`, value);
      return value;
    }

    function parseGPX(gpxText) {
      try {
        const parser = new DOMParser();
        const xml = parser.parseFromString(gpxText, 'application/xml');
        const trkpts = Array.from(xml.getElementsByTagName('trkpt'));
        
        let mypts = [];
        for (let i = 0; i < trkpts.length; i++) {
          const latStr = trkpts[i].getAttribute('lat');
          const lonStr = trkpts[i].getAttribute('lon');
          const eleNode = trkpts[i].querySelector('ele');  // Access subelement
          const ele = eleNode ? parseFloat(eleNode.textContent) : null;
          if (latStr && lonStr && !isNaN(parseFloat(latStr)) && !isNaN(parseFloat(lonStr))) {
            mypts.push({
              lat: parseFloat(latStr),
              lon: parseFloat(lonStr),
              ele: ele
            });
          }
        }
  //      console.log(`Parsed ${mypts.length} track points`);
        return mypts;
      } catch (e) {
        console.error('GPX XML parsing failed:', e);
        return [];
      }
    }

       function findClimbs({
      points,                  // [{lat, lon, ele}, ...] GPX points
      indices,                 // Optional pre-simplified indices
      simplifyPoints = true,   // Douglas-Peucker simplify?
      courseDistance = 0,      // Total route km (auto if 0)
      threshold = 0.2,         // Min rating (m @10%)
      sign = 1,                // 1=up, -1=down, 0=both
      maxDepth = 10            // Recursion guard
    } = {}) {
      if (!points?.length || points.length < 2 || maxDepth <= 0) return [];

      // Auto-compute courseDistance
      const totalDist = courseDistance || turf.length(
        { type: 'LineString', coordinates: points.map(p => [p.lon, p.lat]) },
        { units: 'kilometers' }
      );

      // Indices: simplify or full
      indices ??= simplifyPoints
        ? simplifyProfile(points, totalDist)
        : points.map((_, i) => i);

      if (indices.length < 2) return [];


      // BRUTE-FORCE: Find max rating segment (O(n^2), fine post-simplify)
      let maxRating = threshold;
      let bestRange = null;
      let segPoints;
      for (let j = 1; j < indices.length; j++) {
        for (let i = 0; i < j; i++) {
          if (Math.abs(indices[j] - indices[i]) < 3) continue;  // Min 3 pts/segment
          //        if ((indices[j] + 1) >= indices[i]) {
          segPoints = points.slice(indices[i], indices[j] + 1);
          //        } else {
          //      segPoints = points.slice(indices[j] + 1, indices[i]);
          //       }
          const details = climbRating({ points: segPoints });
          let r = sign === 0 ? Math.abs(details.rating) : details.rating * sign;
          if (r > maxRating) {
            maxRating = r;
            bestRange = { i, j, ...details };
          }
        }
      }

      const climbs = [];
      if (bestRange && maxRating >= threshold) {
        // PREFIX recurse (before climb)
        if (bestRange.i > 0) {
          const prefixLen = turf.length(
            { type: 'LineString', coordinates: points.slice(indices[0], indices[bestRange.i] + 1).map(p => [p.lon, p.lat]) },
            { units: 'kilometers' }
          );
          climbs.push(...findClimbs({
            points,
            indices: indices.slice(0, bestRange.i),
            simplifyPoints: false,
            courseDistance: prefixLen,
            threshold,
            sign,
            maxDepth: maxDepth - 1
          }));
        }

        // THIS CLIMB (enhanced details)
        climbs.push([indices[bestRange.i], indices[bestRange.j], {
          rating: maxRating,
          gain: bestRange.gain,
          distKm: bestRange.distKm,
          avgGrad: bestRange.avgGrad
        }]);

        // SUFFIX recurse (after climb)
        if (bestRange.j < indices.length - 1) {
          const suffixLen = turf.length(
            { type: 'LineString', coordinates: points.slice(indices[bestRange.j], indices.at(-1) + 1).map(p => [p.lon, p.lat]) },
            { units: 'kilometers' }
          );
          climbs.push(...findClimbs({
            points,
            indices: indices.slice(bestRange.j + 1),
            simplifyPoints: false,
            courseDistance: suffixLen,
            threshold,
            sign,
            maxDepth: maxDepth - 1
          }));
        }
      }

      return climbs;
    }

    function climbRating({ points }) {
      if (points.length < 2) return 0;
      const gain = points[points.length - 1].ele - points[0].ele;
      if (gain <= 0) {
        const rating = 0;
        return { rating };
      }

      const coords = points.map(p => [p.lon, p.lat]);
      const distKm = turf.length({ type: 'LineString', coordinates: coords }, { units: 'kilometers' });  // FIXED [web:52]
      const distM = distKm * 1000;
      const avgGrad = (gain / distM) * 100;

      //const rating = Math.pow(Math.max(0, gain), 2) / 10 * Math.pow(avgGrad / 10, -1);

      const rating = Math.pow(Math.max(0, gain), 2) / (distM * 10); //fiets
      //const rating = Math.max(0, gain)*(1 + Math.pow(10*Math.max(0, gain)/distM, 2)); //cbb

      return { rating, gain, distKm, avgGrad };
    }

    function simplifyProfile(points, courseDistance) {
      if (!points || points.length < 3) return points.map((_, i) => i);
      const coords = points.map(p => [p.lon, p.lat]);
      //const tolerance = (courseDistance || 50) / 1000 * Math.pow(2, 0.5) * 0.01;
      const tolerance = 0.001;
      const simplified = turf.simplify({ type: 'LineString', coordinates: coords }, { tolerance, highQuality: true });

      const simpIndices = [];
      let maxoi = 0;
      simplified.coordinates.forEach(sc => {  // FIXED: geometry access [web:51]
        let minDist = Infinity, bestIdx = 0;
        coords.forEach((oc, oi) => {
          if (oi <= maxoi || oi > (maxoi + 100)) return;
          const d = turf.distance(sc, oc, { units: 'meters' });
          if (d < minDist) { minDist = d; bestIdx = oi; maxoi = oi;}
        });
        /*if (minDist < 10)*/ simpIndices.push(bestIdx);
      });
      // return circularUniq(simpIndices);
      return simpIndices;
    }
    // Utils
    function circularUniq(arr) {
      const uniq = [];
      for (let i = 0; i < arr.length; i++) {
        if (!uniq.includes(arr[i])) uniq.push(arr[i]);
        // if (uniq.length >= arr.length / 2) break;  // Prevent over-simplify loops
      }
      return uniq;
    }

    function distance(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = ((lat2 - lat1) * Math.PI) / 180;
      const dLon = ((lon2 - lon1) * Math.PI) / 180;
      const a = Math.sin(dLat / 2) ** 2 + Math.cos((lat1 * Math.PI) / 180) * 
                Math.cos((lat2 * Math.PI) / 180) * Math.sin(dLon / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function findPolylinesInGPXLayer(gpxLayer) {
      let polylines = [];
      Object.values(gpxLayer._layers || {}).forEach(layer => {
        if (layer._layers) {
          Object.values(layer._layers).forEach(subLayer => {
            if (Array.isArray(subLayer._latlngs) && subLayer._latlngs.length > 1) {
              polylines.push(subLayer);
            }
          });
        } else if (Array.isArray(layer._latlngs) && layer._latlngs.length > 1) {
          polylines.push(layer);
        }
      });
//      console.log(`Found ${polylines.length} polylines`);
      return polylines;
    }

    function interpolatePointOnLine(latlngs, ratio, mapInstance) {
      let totalDistance = 0;
      const distances = [];
      for (let i = 0; i < latlngs.length - 1; i++) {
        const dist = mapInstance.distance(latlngs[i], latlngs[i + 1]);
        distances.push(dist);
        totalDistance += dist;
      }
      const targetDistance = totalDistance * ratio;
      let accumulated = 0;
      for (let i = 0; i < distances.length; i++) {
        if (accumulated + distances[i] >= targetDistance) {
          const segmentRatio = (targetDistance - accumulated) / distances[i];
          return L.latLng(
            latlngs[i].lat + segmentRatio * (latlngs[i + 1].lat - latlngs[i].lat),
            latlngs[i].lng + segmentRatio * (latlngs[i + 1].lng - latlngs[i].lng)
          );
        }
        accumulated += distances[i];
      }
      return latlngs[latlngs.length - 1];
    }

 // FIXED: Proper units handling
function distanceToNearestVertex(latlngs, target, toleranceMeters, mapInstance) {
  let totalDistanceKm = 0;  // Track distance in KM
  let minDistanceKm = Infinity;
  let nearestIndex = -1;

  // Find closest point within tolerance (using KM)
  for (let i = 0; i < latlngs.length; i++) {
    const distKm = mapInstance.distance(latlngs[i], target)/1000;  // Leaflet returns KM
    if (distKm < minDistanceKm) {
      minDistanceKm = distKm;
      nearestIndex = i;
    }
  }

//  console.log(`Coffee closest: ${minDistanceKm}m at index ${nearestIndex}`);

  // Check if within tolerance (convert toleranceMeters to KM)
  if (minDistanceKm <= toleranceMeters) {
    // Calculate distance along track from start to nearest point (in KM)
    for (let i = 0; i < nearestIndex; i++) {
      totalDistanceKm += mapInstance.distance(latlngs[i], latlngs[i + 1]);
    }
//    console.log(`Distance along track: ${totalDistanceKm.toFixed(2)} m`);
    return totalDistanceKm;  // Return METERS for display logic
  }
  
//  console.log('Coffee outside 50m tolerance');
  return null;
}

    async function getTowns() {
      try {
        const response = await fetch(
          'https://script.google.com/macros/s/AKfycbxPapZqH6M-bVeiFCtXjYzlMTPlR_86k5X_XCGrB34hES_p7y9GIpSmavdzqb-xFrrohQ/exec?sheet=Villages'
        );
        return await response.json();
      } catch (error) {
   //     console.error('Failed to load towns:', error);
        return [];
      }
    }

    async function loadGPXWithText(gpxText, coffeeLat, coffeeLon, dist, deniv) {
      const myPoints = parseGPX(gpxText);

      const climbs = findClimbs({points : myPoints});

      console.log(climbs);

      const pdeproximityKm = 0.1;
      let pdeEncountered = [];

      try {
        const response = await fetch('https://raw.githubusercontent.com/Chr1sG1thub/InfoCyclisme/refs/heads/main/eau.json');
        const locations = await response.json();
        locations.forEach(loc => {
          if (loc.Display === 'Y') {
            for (const pt of myPoints) {
              if (distance(pt.lat, pt.lon, loc.Lat, loc.Lon) <= pdeproximityKm) {
                pdeEncountered.push(loc);
                break;
              }
            }
          }
        });
      } catch (error) {
    //    console.error('Failed to load water points:', error);
      }

      const townproximityKm = 0.25;
      let townsEncountered = [];
      towns.forEach(town => {
        for (const pt of myPoints) {
          if (distance(pt.lat, pt.lon, town.Lat, town.Lon) <= townproximityKm) {
            townsEncountered.push(town);
            break;
          }
        }
      });

      townsEncountered.sort((a, b) => a.Place.localeCompare(b.Place));
      const filteredTowns = townsEncountered.filter(
        (t, i, arr) => i === 0 || t.Place !== arr[i - 1].Place
      );

      if (!map) {
        map = L.map('map').setView([43.6, 2], 10);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '¬© OpenStreetMap contributors'
        }).addTo(map);
      } else {
        map.eachLayer(layer => {
          if (!(layer instanceof L.TileLayer)) map.removeLayer(layer);
        });
      }

      const icons = {
        water: L.icon({iconUrl: 'water.png', iconSize: [24,24], iconAnchor: [12,12]}),
        tap: L.icon({iconUrl: 'tap.png', iconSize: [24,24], iconAnchor: [12,12]}),
        fountain: L.icon({iconUrl: 'fountain.png', iconSize: [24,24], iconAnchor: [12,12]}),
        toilets: L.icon({iconUrl: 'toilets.png', iconSize: [24,24], iconAnchor: [12,12]}),
        coffee: L.icon({iconUrl: 'coffee.png', iconSize: [24,24], iconAnchor: [12,12]}),
        mountain: L.icon({iconUrl: 'mountain.png', iconSize: [24,24], iconAnchor: [12,12]}),
        asc1: L.icon({iconUrl: 'asc1.png', iconSize: [24,24], iconAnchor: [12,12]}),
        asc2: L.icon({iconUrl: 'asc2.png', iconSize: [24,24], iconAnchor: [12,12]}),
        asc3: L.icon({iconUrl: 'asc3.png', iconSize: [24,24], iconAnchor: [12,12]}),
        asc4: L.icon({iconUrl: 'asc4.png', iconSize: [24,24], iconAnchor: [12,12]}),
        asc5: L.icon({iconUrl: 'asc5.png', iconSize: [24,24], iconAnchor: [12,12]}),
        asc6: L.icon({iconUrl: 'asc6.png', iconSize: [24,24], iconAnchor: [12,12]}),
        asc7: L.icon({iconUrl: 'asc7.png', iconSize: [24,24], iconAnchor: [12,12]}),
        asc8: L.icon({iconUrl: 'asc8.png', iconSize: [24,24], iconAnchor: [12,12]}),
        asc9: L.icon({iconUrl: 'asc9.png', iconSize: [24,24], iconAnchor: [12,12]})
      };

const gpxLayer = new L.GPX(gpxText, {
  async: true,
  polyline_options: {
    color: 'blue',
    weight: 4,
    opacity: 0.9
  },
  markers: { startIcon: 'start.ico', endIcon: 'finish.ico' },
  marker_options: { iconSize: [20, 20], iconAnchor: [10, 10] }
})
.on('loaded', function (e) {
  const gpxLayer = e.target;
  map.fitBounds(gpxLayer.getBounds());

/*  var isoscelesArrow = L.Symbol.path({
  pathOptions: { fillOpacity: 1, weight: 0, color: '#yourColor' },
  path: [
    [0, -15],  // Sharp tip
    [-10, 5],  // Left base (wider for isosceles)
    [10, 5]    // Right base
  ]
}); */

  const polylines = findPolylinesInGPXLayer(gpxLayer);
  polylines.forEach(polyline => {
    // arrows
    L.polylineDecorator(polyline, {
      patterns: [{
        offset: '3%',
        repeat: '5%',
        symbol: L.Symbol.arrowHead({
          pixelSize: 12,
          polygon: true,
          pathOptions: {
            color: 'blue',
            weight: 2,
            opacity: 1,
            fill: true,
            fillColor: 'blue',
            fillOpacity: 1
          }
        })
      }]
    }).addTo(map);

    const poplatlngs = polyline.getLatLngs();

const bounds = myPoints.reduce((bounds, point) => {
  bounds.minLat = Math.min(bounds.minLat, point.lat);
  bounds.maxLat = Math.max(bounds.maxLat, point.lat);
  bounds.minLon = Math.min(bounds.minLon, point.lon);
  bounds.maxLon = Math.max(bounds.maxLon, point.lon);
  return bounds;
}, { minLat: Infinity, maxLat: -Infinity, minLon: Infinity, maxLon: -Infinity });

    // parcours popup
    if (dist && dist !== "N/A") {
//      const popupPoint = interpolatePointOnLine(poplatlngs, 0.25, map);
      L.popup({ className: 'parcourspop' })
        .setLatLng(L.latLng((bounds.maxLat + bounds.minLat)/2, (bounds.maxLon + bounds.minLon)/2))
        .setContent(`<span style='font-size: 10px;'>üö¥ : ${dist}km, ${deniv}m D+</span>`)
        .addTo(map);
    }

    // peak popup + marker
    const maxEleIndex = myPoints.reduce((maxIdx, pt, idx, arr) =>
      arr[maxIdx]?.ele > pt.ele ? maxIdx : idx, 0
    );
    const peak = myPoints[maxEleIndex];

    const minEleIndex = myPoints.reduce((minIdx, pt, idx, arr) =>
      arr[minIdx]?.ele < pt.ele ? minIdx : idx, 0
    );
    const trough = myPoints[minEleIndex];

 //   console.log(`Min  = ${trough.ele.toFixed(0)}m at ${trough.lat}, ${trough.lon}.`);

    /*const peakMarker = L.marker([peak.lat, peak.lon], {
      icon: icons.mountain,
      zIndexOffset: 1000
    }).addTo(map);*/

    for (let iclimb = 0; iclimb < climbs.length; iclimb++) {
/*      L.popup({ className: 'elevationpop' })
      .setLatLng([myPoints[climbs[iclimb][0]].lat, myPoints[climbs[iclimb][0]].lon])
      .setContent(`<span style='font-size: 10px;'>‚õ∞ Dep ${iclimb + 1}: ${climbs[iclimb][2].gain.toFixed(0)}m</span>`)
      .addTo(map); 
      
      L.popup({ className: 'elevationpop' })
      .setLatLng([myPoints[climbs[iclimb][1]].lat, myPoints[climbs[iclimb][1]].lon])
      .setContent(`<span style='font-size: 10px;'>‚õ∞ Arr ${iclimb + 1}</span>`)
      .addTo(map);*/

      if (iclimb == 0) {
        L.marker([myPoints[climbs[iclimb][0]].lat, myPoints[climbs[iclimb][0]].lon], {
        icon: icons.asc1,
        zIndexOffset: 1000
      }).addTo(map).bindPopup(`${climbs[iclimb][2].distKm.toFixed(1)}km, ${climbs[iclimb][2].gain.toFixed(0)}m D+, ${climbs[iclimb][2].avgGrad.toFixed(1)}%`);
      } else if (iclimb == 1) {
        L.marker([myPoints[climbs[iclimb][0]].lat, myPoints[climbs[iclimb][0]].lon], {
        icon: icons.asc2,
        zIndexOffset: 1000
      }).addTo(map).bindPopup(`${climbs[iclimb][2].distKm.toFixed(1)}km, ${climbs[iclimb][2].gain.toFixed(0)}m D+, ${climbs[iclimb][2].avgGrad.toFixed(1)}%`);
      } else if (iclimb == 2) {
        L.marker([myPoints[climbs[iclimb][0]].lat, myPoints[climbs[iclimb][0]].lon], {
        icon: icons.asc3,
        zIndexOffset: 1000
      }).addTo(map).bindPopup(`${climbs[iclimb][2].distKm.toFixed(1)}km, ${climbs[iclimb][2].gain.toFixed(0)}m D+, ${climbs[iclimb][2].avgGrad.toFixed(1)}%`);
      } else if (iclimb == 3) {
        L.marker([myPoints[climbs[iclimb][0]].lat, myPoints[climbs[iclimb][0]].lon], {
        icon: icons.asc4,
        zIndexOffset: 1000
      }).addTo(map).bindPopup(`${climbs[iclimb][2].distKm.toFixed(1)}km, ${climbs[iclimb][2].gain.toFixed(0)}m D+, ${climbs[iclimb][2].avgGrad.toFixed(1)}%`);
      } else if (iclimb == 4) {
        L.marker([myPoints[climbs[iclimb][0]].lat, myPoints[climbs[iclimb][0]].lon], {
        icon: icons.asc5,
        zIndexOffset: 1000
      }).addTo(map).bindPopup(`${climbs[iclimb][2].distKm.toFixed(1)}km, ${climbs[iclimb][2].gain.toFixed(0)}m D+, ${climbs[iclimb][2].avgGrad.toFixed(1)}%`);
      } else if (iclimb == 5) {
        L.marker([myPoints[climbs[iclimb][0]].lat, myPoints[climbs[iclimb][0]].lon], {
        icon: icons.asc6,
        zIndexOffset: 1000
      }).addTo(map).bindPopup(`${climbs[iclimb][2].distKm.toFixed(1)}km, ${climbs[iclimb][2].gain.toFixed(0)}m D+, ${climbs[iclimb][2].avgGrad.toFixed(1)}%`);
      } else if (iclimb == 6) {
        L.marker([myPoints[climbs[iclimb][0]].lat, myPoints[climbs[iclimb][0]].lon], {
        icon: icons.asc7,
        zIndexOffset: 1000
      }).addTo(map).bindPopup(`${climbs[iclimb][2].distKm.toFixed(1)}km, ${climbs[iclimb][2].gain.toFixed(0)}m D+, ${climbs[iclimb][2].avgGrad.toFixed(1)}%`);
      } else if (iclimb == 7) {
        L.marker([myPoints[climbs[iclimb][0]].lat, myPoints[climbs[iclimb][0]].lon], {
        icon: icons.asc8,
        zIndexOffset: 1000
      }).addTo(map).bindPopup(`${climbs[iclimb][2].distKm.toFixed(1)}km, ${climbs[iclimb][2].gain.toFixed(0)}m D+, ${climbs[iclimb][2].avgGrad.toFixed(1)}%`);
      } else if (iclimb == 8) {
        L.marker([myPoints[climbs[iclimb][0]].lat, myPoints[climbs[iclimb][0]].lon], {
        icon: icons.asc9,
        zIndexOffset: 1000
      }).addTo(map).bindPopup(`${climbs[iclimb][2].distKm.toFixed(1)}km, ${climbs[iclimb][2].gain.toFixed(0)}m D+, ${climbs[iclimb][2].avgGrad.toFixed(1)}%`);
      }
      
    } 

/*    let prevMarker = null; // Tracks the currently displayed second marker

map.on('popupopen', function(e) {
  const sourceMarker = e.popup._source; // Marker whose popup opened
  if (prevMarker) {
    map.removeLayer(prevMarker); // Hide previous second marker
  }
  // Create new marker, e.g., 0.001 degrees northeast of source
  const newLatLng = [
    myPoints[climbs[0][1]].lat,
   myPoints[climbs[0][1]].lon
  ];
  prevMarker = L.marker(newLatLng).addTo(map);
});

map.on('popupclose', function(e) {
  if (prevMarker) {
    map.removeLayer(prevMarker);
    prevMarker = null;
  }
}); */

    /* L.popup({ className: 'elevationpop' })
      .setLatLng([peak.lat, peak.lon])
      .setContent(`<span style='font-size: 10px;'>‚õ∞ Max : ${peak.ele.toFixed(0)}m</span>`)
      .addTo(map);

      L.popup({ className: 'elevationpop' })
      .setLatLng([trough.lat, trough.lon])
      .setContent(`<span style='font-size: 10px;'>‚õ∞ Min : ${trough.ele.toFixed(0)}m</span>`)
      .addTo(map); */

     // coffee popup + marker
    if (coffeeLat && coffeeLon) {
      const targetPoint = L.latLng(parseFloat(coffeeLat), parseFloat(coffeeLon));
      const toleranceMeters = 50;
      const distAlong = distanceToNearestVertex(poplatlngs, targetPoint, toleranceMeters, map);
      const kms = distAlong ? Math.round(distAlong / 1000) : 'N/A (trop loin)';

      /*const cMarker = L.marker([parseFloat(coffeeLat), parseFloat(coffeeLon)], {
        icon: icons.coffee,
        zIndexOffset: 1000
      }).addTo(map);*/

  map.createPane('customPopupPane');
map.getPane('customPopupPane').style.zIndex = 850;

var popup = L.popup({ pane: 'customPopupPane' });
    L.popup({ className: 'cafepop', pane: 'customPopupPane' })
        .setLatLng([parseFloat(coffeeLat)/*+0.0008*/, parseFloat(coffeeLon)])
        .setContent(`<span style='font-size: 10px;'>‚òï √† ${kms}km</span>`)
        .addTo(map);
    }

  });

 // towns & water markers
  filteredTowns.forEach(ft => {
    const myIcon = L.divIcon({
      className: 'custom-div-icon',
      html: `<span style="color:red; background-color: yellow; line-height: 0.9; display: inline-block; text-align: center; opacity: 0.8;"><strong>${ft.Place}</strong></span>`,
      iconSize: [ft.Place.length * 10, 20],
      iconAnchor: [ft.Place.length * 3, 7]
    });
    L.marker([ft.nLat, ft.nLon], { icon: myIcon, zIndexOffset: 1000 }).addTo(map);
  });

  pdeEncountered.forEach(pe => {
    let iconToUse = icons.water;
    if (pe.Type === 'Fontaine') iconToUse = icons.fountain;
    else if (pe.Type === 'Robinet') iconToUse = icons.tap;
    else if (pe.Type === 'Toilettes') iconToUse = icons.toilets;

    L.marker([pe.Lat, pe.Lon], { icon: iconToUse }).addTo(map);
  });
})
.addTo(map);
  }

    async function main() {
      
      const fileInput = document.getElementById('gpxFile');
//      const statusEl = document.getElementById('urlStatus');
      
      const filename = getQueryParam('gpxFile');
      const coffeeLat = getQueryParam('clat');
      const coffeeLon = getQueryParam('clon');
      const dist = getQueryParam('dist');
      const deniv = getQueryParam('deniv');

      if (!filename) {
        document.getElementById('controls').style.display = "block";
      }
      towns = await getTowns();
      
/*      statusEl.innerHTML = `
        <strong>URL Params:</strong><br>
        gpxFile: ${filename || 'NULL'}<br>
        clat: ${coffeeLat || 'NULL'}<br>
        clon: ${coffeeLon || 'NULL'}<br>
        dist: ${dist}<br>
        deniv: ${deniv}
      `; */

      if (!coffeeLat || !coffeeLon) {
   //     console.warn('No coffee stop coordinates provided (clat/clon)');
      }

      fileInput.onchange = async (e) => {
        const file = e.target.files[0];
        if (file) {
 //         statusEl.innerHTML = 'Loading local GPX file...';
          const gpxText = await file.text();
          await loadGPXWithText(gpxText, coffeeLat, coffeeLon, dist, deniv);
 //         statusEl.innerHTML = 'Local GPX loaded successfully!';
        }
      };

      if (filename) {
  //      statusEl.innerHTML += '<br>Loading GPX from server: gpx/' + filename + '...';
        try {
          const response = await fetch(`gpx/${filename}`);
  //        console.log('Fetch response:', response.status, response.statusText);
          
          if (response.ok) {
            const gpxText = await response.text();
            await loadGPXWithText(gpxText, coffeeLat, coffeeLon, dist, deniv);
   //         statusEl.innerHTML += '<br><span style="color: green">‚úÖ Server GPX loaded!</span>';
          } else {
   //         statusEl.innerHTML += `<br><span style="color: red">‚ùå Failed: ${response.status}</span>`;
   //        console.error('Fetch failed:', response.status, response.statusText);
          }
        } catch (error) {
  //        statusEl.innerHTML += `<br><span style="color: red">‚ùå Error: ${error.message}</span>`;
     //     console.error('Fetch error:', error);
        }
      } else {
        null;
  //      statusEl.innerHTML += '<br><span style="color: orange">No gpxFile param - use file input or ?gpxFile=route.gpx</span>';
      }
    }

    main();
  </script>
</body>
</html>
