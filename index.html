<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>TownsOnMap</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet/dist/leaflet.css" />
  <script src="https://unpkg.com/leaflet/dist/leaflet.js"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/leaflet-gpx/2.2.0/gpx.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/leaflet-polylinedecorator@1.6.0/dist/leaflet.polylineDecorator.min.js"></script>
  <script src="https://unpkg.com/@mapbox/togeojson@2.2.1/togeojson.js"></script>

  <style>
    #map { height: 800px; width: 100%; }
    body { font-family: Arial, sans-serif; margin: 20px; }
    #results { white-space: pre-wrap; margin-top: 20px; }
    .custom-div-icon { font-weight: bold; }
    .controls { margin-bottom: 20px; padding: 10px; background: #f0f0f0; border-radius: 5px; display: none;}
    .status { margin: 10px 0; padding: 10px; background: #e0f7fa; border-radius: 5px; font-size: 14px; }
  </style>
</head>

<body>
  <div id="controls" class="controls">
    <input type="file" id="gpxFile" accept=".gpx" style="margin-right: 10px;">
    <!-- <span id="urlStatus">Checking URL parameters...</span> -->
  </div>
  
  <div id="map"></div>

  <script>
    let map;
    let towns = [];

    function getQueryParam(name) {
      const value = new URLSearchParams(window.location.search).get(name);
      console.log(`Query param "${name}":`, value);
      return value;
    }

    function parseGPX(gpxText) {
      try {
        const parser = new DOMParser();
        const xml = parser.parseFromString(gpxText, 'application/xml');
        const trkpts = Array.from(xml.getElementsByTagName('trkpt'));
        
        let mypts = [];
        for (let i = 0; i < trkpts.length; i++) {
          const latStr = trkpts[i].getAttribute('lat');
          const lonStr = trkpts[i].getAttribute('lon');
          if (latStr && lonStr && !isNaN(parseFloat(latStr)) && !isNaN(parseFloat(lonStr))) {
            mypts.push({
              lat: parseFloat(latStr),
              lon: parseFloat(lonStr)
            });
          }
        }
        console.log(`Parsed ${mypts.length} track points`);
        return mypts;
      } catch (e) {
        console.error('GPX XML parsing failed:', e);
        return [];
      }
    }

    function distance(lat1, lon1, lat2, lon2) {
      const R = 6371;
      const dLat = ((lat2 - lat1) * Math.PI) / 180;
      const dLon = ((lon2 - lon1) * Math.PI) / 180;
      const a = Math.sin(dLat / 2) ** 2 + Math.cos((lat1 * Math.PI) / 180) * 
                Math.cos((lat2 * Math.PI) / 180) * Math.sin(dLon / 2) ** 2;
      return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }

    function findPolylinesInGPXLayer(gpxLayer) {
      let polylines = [];
      Object.values(gpxLayer._layers || {}).forEach(layer => {
        if (layer._layers) {
          Object.values(layer._layers).forEach(subLayer => {
            if (Array.isArray(subLayer._latlngs) && subLayer._latlngs.length > 1) {
              polylines.push(subLayer);
            }
          });
        } else if (Array.isArray(layer._latlngs) && layer._latlngs.length > 1) {
          polylines.push(layer);
        }
      });
      console.log(`Found ${polylines.length} polylines`);
      return polylines;
    }

    function interpolatePointOnLine(latlngs, ratio, mapInstance) {
      let totalDistance = 0;
      const distances = [];
      for (let i = 0; i < latlngs.length - 1; i++) {
        const dist = mapInstance.distance(latlngs[i], latlngs[i + 1]);
        distances.push(dist);
        totalDistance += dist;
      }
      const targetDistance = totalDistance * ratio;
      let accumulated = 0;
      for (let i = 0; i < distances.length; i++) {
        if (accumulated + distances[i] >= targetDistance) {
          const segmentRatio = (targetDistance - accumulated) / distances[i];
          return L.latLng(
            latlngs[i].lat + segmentRatio * (latlngs[i + 1].lat - latlngs[i].lat),
            latlngs[i].lng + segmentRatio * (latlngs[i + 1].lng - latlngs[i].lng)
          );
        }
        accumulated += distances[i];
      }
      return latlngs[latlngs.length - 1];
    }

 // FIXED: Proper units handling
function distanceToNearestVertex(latlngs, target, toleranceMeters, mapInstance) {
  let totalDistanceKm = 0;  // Track distance in KM
  let minDistanceKm = Infinity;
  let nearestIndex = -1;

  // Find closest point within tolerance (using KM)
  for (let i = 0; i < latlngs.length; i++) {
    const distKm = mapInstance.distance(latlngs[i], target)/1000;  // Leaflet returns KM
    if (distKm < minDistanceKm) {
      minDistanceKm = distKm;
      nearestIndex = i;
    }
  }

  console.log(`Coffee closest: ${minDistanceKm}m at index ${nearestIndex}`);

  // Check if within tolerance (convert toleranceMeters to KM)
  if (minDistanceKm <= toleranceMeters) {
    // Calculate distance along track from start to nearest point (in KM)
    for (let i = 0; i < nearestIndex; i++) {
      totalDistanceKm += mapInstance.distance(latlngs[i], latlngs[i + 1]);
    }
    console.log(`Distance along track: ${totalDistanceKm.toFixed(2)} m`);
    return totalDistanceKm;  // Return METERS for display logic
  }
  
  console.log('Coffee outside 50m tolerance');
  return null;
}

    async function getTowns() {
      try {
        const response = await fetch(
          'https://script.google.com/macros/s/AKfycbxPapZqH6M-bVeiFCtXjYzlMTPlR_86k5X_XCGrB34hES_p7y9GIpSmavdzqb-xFrrohQ/exec?sheet=Villages'
        );
        return await response.json();
      } catch (error) {
        console.error('Failed to load towns:', error);
        return [];
      }
    }

    async function loadGPXWithText(gpxText, coffeeLat, coffeeLon, dist, deniv) {
      const mypoints = parseGPX(gpxText);

      const pdeproximityKm = 0.1;
      let pdeEncountered = [];

      try {
        const response = await fetch('https://raw.githubusercontent.com/Chr1sG1thub/InfoCyclisme/refs/heads/main/eau.json');
        const locations = await response.json();
        locations.forEach(loc => {
          if (loc.Display === 'Y') {
            for (const pt of mypoints) {
              if (distance(pt.lat, pt.lon, loc.Lat, loc.Lon) <= pdeproximityKm) {
                pdeEncountered.push(loc);
                break;
              }
            }
          }
        });
      } catch (error) {
        console.error('Failed to load water points:', error);
      }

      const townproximityKm = 0.25;
      let townsEncountered = [];
      towns.forEach(town => {
        for (const pt of mypoints) {
          if (distance(pt.lat, pt.lon, town.Lat, town.Lon) <= townproximityKm) {
            townsEncountered.push(town);
            break;
          }
        }
      });

      townsEncountered.sort((a, b) => a.Place.localeCompare(b.Place));
      const filteredTowns = townsEncountered.filter(
        (t, i, arr) => i === 0 || t.Place !== arr[i - 1].Place
      );

      if (!map) {
        map = L.map('map').setView([43.6, 2], 10);
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
          attribution: '© OpenStreetMap contributors'
        }).addTo(map);
      } else {
        map.eachLayer(layer => {
          if (!(layer instanceof L.TileLayer)) map.removeLayer(layer);
        });
      }

      const icons = {
        water: L.icon({iconUrl: 'water.png', iconSize: [30,30], iconAnchor: [15,15]}),
        tap: L.icon({iconUrl: 'tap.png', iconSize: [30,30], iconAnchor: [15,15]}),
        fountain: L.icon({iconUrl: 'fountain.png', iconSize: [30,30], iconAnchor: [15,15]}),
        toilets: L.icon({iconUrl: 'toilets.png', iconSize: [30,30], iconAnchor: [15,15]}),
        coffee: L.icon({iconUrl: 'coffee.png', iconSize: [30,30], iconAnchor: [15,15]})
      };

      new L.GPX(gpxText, {
        async: true,
        markers: { startIcon: 'start.ico', endIcon: 'finish.ico' },
        marker_options: { iconSize: [12,12], iconAnchor: [6,6] }
      }).on('loaded', function(e) {
        const gpxLayer = e.target;
        map.fitBounds(gpxLayer.getBounds());

        const polylines = findPolylinesInGPXLayer(gpxLayer);
        polylines.forEach(polyline => {
          L.polylineDecorator(polyline, {
            patterns: [{
              offset: '3%', repeat: '5%',
              symbol: L.Symbol.arrowHead({pixelSize: 12, polygon: true, 
                pathOptions: {color: 'blue', weight: 2, opacity: 1, fill: true, fillColor: 'blue', fillOpacity: 1}})
            }]
          }).addTo(map);

      const poplatlngs = polyline.getLatLngs();
    if (dist && dist != "N/A") {
          const popupPoint = interpolatePointOnLine(poplatlngs, 0.25, map);
          L.popup().setLatLng(popupPoint)
            .setContent(`<span style='font-size: 10px'>Parcours : ${dist}km, ${deniv}m</span>`)
            .addTo(map);
    }

          // FIXED: Coffee distance calculation
          if (coffeeLat && coffeeLon) {
            console.log('Calculating coffee distance for:', coffeeLat, coffeeLon);
            const targetPoint = L.latLng(parseFloat(coffeeLat), parseFloat(coffeeLon));
            const toleranceMeters = 50;
            const distAlong = distanceToNearestVertex(poplatlngs, targetPoint, toleranceMeters, map);
            
            const kms = distAlong ? Math.round(distAlong / 1000) : 'N/A (trop loin)';
            console.log(`Coffee km result: ${kms}`);
            
            const cMarker = L.marker([parseFloat(coffeeLat), parseFloat(coffeeLon)], { 
              icon: icons.coffee, 
              zIndexOffset: 1000 
            }).addTo(map);
            
            L.popup({offset: [0, -10]})
              .setLatLng([parseFloat(coffeeLat), parseFloat(coffeeLon)])
              .setContent(`<span style='font-size: 10px'>Pause Café à ${kms}km</span>`)
              .addTo(map);
          }
        });

        filteredTowns.forEach(ft => {
          const myIcon = L.divIcon({
            className: 'custom-div-icon',
            html: `<span style="color:red; background-color: yellow; line-height: 0.9; display: inline-block; text-align: center; opacity: 0.8;"><strong>${ft.Place}</strong></span>`,
            iconSize: [ft.Place.length * 10, 20],
            iconAnchor: [ft.Place.length * 3, 7]
          });
          L.marker([ft.nLat, ft.nLon], { icon: myIcon, zIndexOffset: 1000 }).addTo(map);
        });

        pdeEncountered.forEach(pe => {
          let iconToUse = icons.water;
          if (pe.Type === 'Fontaine') iconToUse = icons.fountain;
          else if (pe.Type === 'Robinet') iconToUse = icons.tap;
          else if (pe.Type === 'Toilettes') iconToUse = icons.toilets;
          
          L.marker([pe.Lat, pe.Lon], { icon: iconToUse }).addTo(map);
        });
      }).addTo(map);
    }

    async function main() {
      
      const fileInput = document.getElementById('gpxFile');
//      const statusEl = document.getElementById('urlStatus');
      
      const filename = getQueryParam('gpxFile');
      const coffeeLat = getQueryParam('clat');
      const coffeeLon = getQueryParam('clon');
      const dist = getQueryParam('dist');
      const deniv = getQueryParam('deniv');

      if (!filename) {
        document.getElementById('controls').style.display = "block";
      }
      towns = await getTowns();
      
/*      statusEl.innerHTML = `
        <strong>URL Params:</strong><br>
        gpxFile: ${filename || 'NULL'}<br>
        clat: ${coffeeLat || 'NULL'}<br>
        clon: ${coffeeLon || 'NULL'}<br>
        dist: ${dist}<br>
        deniv: ${deniv}
      `; */

      if (!coffeeLat || !coffeeLon) {
        console.warn('No coffee stop coordinates provided (clat/clon)');
      }

      fileInput.onchange = async (e) => {
        const file = e.target.files[0];
        if (file) {
 //         statusEl.innerHTML = 'Loading local GPX file...';
          const gpxText = await file.text();
          await loadGPXWithText(gpxText, coffeeLat, coffeeLon, dist, deniv);
 //         statusEl.innerHTML = 'Local GPX loaded successfully!';
        }
      };

      if (!filename) {
  //      statusEl.innerHTML += '<br>Loading GPX from server: gpx/' + filename + '...';
        try {
          const response = await fetch(`gpx/${filename}`);
          console.log('Fetch response:', response.status, response.statusText);
          
          if (response.ok) {
            const gpxText = await response.text();
            await loadGPXWithText(gpxText, coffeeLat, coffeeLon, dist, deniv);
   //         statusEl.innerHTML += '<br><span style="color: green">✅ Server GPX loaded!</span>';
          } else {
   //         statusEl.innerHTML += `<br><span style="color: red">❌ Failed: ${response.status}</span>`;
            console.error('Fetch failed:', response.status, response.statusText);
          }
        } catch (error) {
  //        statusEl.innerHTML += `<br><span style="color: red">❌ Error: ${error.message}</span>`;
          console.error('Fetch error:', error);
        }
      } else {
        null;
  //      statusEl.innerHTML += '<br><span style="color: orange">No gpxFile param - use file input or ?gpxFile=route.gpx</span>';
      }
    }

    main();
  </script>
</body>
</html>
